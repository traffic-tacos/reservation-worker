---
description: Traffic Tacos ì „ì²´ ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ ìƒì„¸
globs:
alwaysApply: true
---

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is the **Traffic Tacos MSA (Microservices Architecture) Platform** - a high-performance ticket reservation system designed to handle **30k RPS traffic**. The system consists of **six main components** including backend services (Go/Kotlin) and frontend (React), following cloud-native patterns with event-driven architecture.

**Important**: Each service is maintained as an **independent Git repository** and built independently with its own **Dockerfile**. This repository contains all services for development purposes, but in production each service is deployed separately from its own repository.

### Architecture Components

**Multi-Layer Architecture:**

```
                    Layer 0: Frontend
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   Reservation Web       â”‚
              â”‚     (React/Vite)        â”‚
              â”‚  â€¢ User Interface       â”‚
              â”‚  â€¢ State Management     â”‚
              â”‚  â€¢ Real-time Updates    â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ HTTP/REST + WebSocket
                        â–¼
                    Layer 1: API Gateway
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚     Gateway API         â”‚
                â”‚    (Go/Fiber)          â”‚
                â”‚  â€¢ Authentication       â”‚
                â”‚  â€¢ Routing             â”‚
                â”‚  â€¢ Rate Limiting       â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ gRPC
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚         â”‚               â”‚
        Layer 2: Business Services        â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ Reservation API â”‚ â”‚  Inventory API  â”‚ â”‚ Payment Sim API â”‚
     â”‚ (Kotlin/Spring) â”‚ â”‚   (Go/gRPC)     â”‚ â”‚   (Go/gRPC)     â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â”‚ Events (EventBridge/SQS)
               â–¼
        Layer 3: Background Processing
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚      Reservation Worker             â”‚
     â”‚      (Kubernetes Job + KEDA)        â”‚
     â”‚   â€¢ Event-driven processing         â”‚
     â”‚   â€¢ Auto-scaling based on queue     â”‚
     â”‚   â€¢ Expiry & cleanup tasks          â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **Layer 0 - Frontend**:
  - **reservation-web**: React-based user interface with real-time updates and state management (React + Vite)
- **Layer 1 - Gateway API**: Single entry point for authentication, routing, and traffic control (Go + Fiber)
- **Layer 2 - Business Services**:
  - **reservation-api**: Core reservation management with 60s hold periods and event publishing (Kotlin + Spring Boot WebFlux)
  - **inventory-api**: High-performance inventory management with zero oversell guarantee (Go + gRPC)
  - **payment-sim-api**: Payment processing simulator with EventBridge + webhook support (Go + gRPC)
- **Layer 3 - Background Processing**:
  - **reservation-worker**: Event-driven Kubernetes job with KEDA auto-scaling for reservation expiry and cleanup tasks

## Development Commands

### AWS Resource Management

**IMPORTANT**: Each service requires actual AWS resources to function properly. Use the AWS resource discovery script to identify and configure the correct resource names:

```bash
# Discover all AWS resources (DynamoDB, SQS, EventBridge, IAM)
./discover_aws_resources.sh

# Generate service-specific .env files with actual resource names
./discover_aws_resources.sh generate

# Check specific AWS resource types
./discover_aws_resources.sh dynamodb      # DynamoDB tables
./discover_aws_resources.sh sqs          # SQS queues
./discover_aws_resources.sh eventbridge  # EventBridge buses and rules
./discover_aws_resources.sh iam          # IAM roles and policies
```

**Key AWS Resources Required:**
- **DynamoDB Tables**: reservations, orders, idempotency, outbox, inventory, inventory_seats
- **SQS Queues**: reservation-worker queue, dead letter queues
- **EventBridge**: Custom event bus, rules for reservation events
- **IAM Roles**: Service roles for DynamoDB access, EventBridge publishing

### Building and Testing

Each service is **independently deployable** with its own build system and **Dockerfile**. Navigate to each service directory and use the respective build commands:

**Reservation API (Kotlin/Gradle):**
```bash
cd reservation-api
# Full local setup with Docker services
./run_local.sh start

# Build only
./gradlew clean build

# Run tests
./gradlew test
./gradlew integrationTest

# Performance tests
./gradlew jmeterRun

# Docker build
docker build -t reservation-api:latest .
```

**Inventory API (Go/Make):**
```bash
cd inventory-api
# Full build and test pipeline
make all

# Individual commands
make build
make test
make lint

# Docker build
make docker-build

# Load testing
make load-test-ghz
```

**Payment Sim API (Go/Make):**
```bash
cd payment-sim-api
# Full CI pipeline
make ci

# Individual commands
make build
make test
make lint

# Docker build
make docker-build

# Performance tests
make perf-test
```

**Gateway API (Go):**
```bash
cd gateway-api
# Build
go build -o gateway-api ./cmd/gateway-api

# Test
go test ./...

# Docker build
docker build -t gateway-api:latest .
```

### Service-Specific Development

**Reservation API** has the most comprehensive development environment:
- `./run_local.sh setup`: Start Docker services (DynamoDB, LocalStack, OTEL)
- `./run_local.sh build`: Build application
- `./run_local.sh start`: Complete setup + build + run
- `./generate_proto.sh`: Regenerate gRPC proto files

**Inventory API** focuses on high performance:
- `make generate`: Generate protobuf Go code
- `make docker-build`: Build Docker image for ARM64/AMD64
- Uses DynamoDB with conditional updates for zero oversell

**Payment Sim API** simulates external payment processing:
- `make run-local`: Start with webhook secret
- Provides webhook endpoints for payment status updates

## Core Architecture Patterns

### Technology Stack by Service

| Layer | Service | Framework | Database | Communication | Key Features |
|-------|---------|-----------|----------|---------------|--------------|
| 0 | Reservation Web | React + Vite | LocalStorage/State | HTTP + WebSocket | SPA, Real-time UI, State management |
| 1 | Gateway | Go + Fiber | Redis | HTTP + JWT | Authentication, Routing, Rate limiting |
| 2 | Reservation | Kotlin + Spring WebFlux | DynamoDB | REST + gRPC | Reactive, Event sourcing |
| 2 | Inventory | Go + gRPC | DynamoDB | gRPC | High performance, Zero oversell |
| 2 | Payment Sim | Go + gRPC | In-memory | gRPC + EventBridge + Webhooks | External API simulation |
| 3 | Reservation Worker | Go/Kotlin | DynamoDB | SQS + Events | K8s Job, KEDA scaling, Background processing |

### Event-Driven Architecture

- **EventBridge**: Custom event bus for inter-service communication
- **SQS Queues**: Message queues for worker job processing
- **Outbox Pattern**: Implemented in reservation-api for reliable event delivery
- **DLQ Support**: Dead letter queues for failed event processing
- **KEDA Scaling**: Auto-scaling based on SQS queue depth
- **Event Types**: `reservation.hold.created`, `reservation.confirmed`, `reservation.expired`, etc.

### Data Consistency Patterns

- **Reservation API**: Uses DynamoDB transactions and idempotency keys (5-min TTL)
- **Inventory API**: DynamoDB conditional updates prevent overselling
- **Cross-service**: Event-driven eventual consistency

### Performance & Resilience

- **Circuit Breakers**: Resilience4j patterns in reservation-api
- **Timeouts**: 250ms for gRPC calls, 600ms max for API responses
- **Caching**: Caffeine cache for reservation-api, Redis for gateway
- **Rate Limiting**: Gateway-level traffic control
- **Health Checks**: Actuator endpoints and Prometheus metrics

### Observability Stack

- **Tracing**: OpenTelemetry with distributed trace correlation
- **Metrics**: Prometheus with business metrics (reservation status, gRPC performance)
- **Logging**: Structured JSON logs with trace IDs
- **Monitoring**: Custom dashboards for 30k RPS performance targets

### Security Implementation

- **Authentication**: JWT OIDC tokens across all services
- **Authorization**: Spring Security in reservation-api
- **Idempotency**: UUID-based request deduplication
- **Secrets**: Environment variable configuration, no hardcoded credentials

## Service Integration Points

### API Communication Flow
1. **Frontend** â†’ **Gateway**: HTTP/REST requests + WebSocket connections
   - **Reservation Web** â†’ **Gateway**: User interactions, real-time updates
2. **Gateway** â†’ **Layer 2 Services**: Authenticated and routed requests
   - **Gateway** â†’ **Reservation**: HTTP/REST with JWT forwarding
   - **Gateway** â†’ **Payment Sim**: HTTP/REST for direct payment operations
3. **Inter-Service Communication (Layer 2 - gRPC)**:
   - **Gateway** â†’ **Reservation**: gRPC calls (CreateReservation, GetReservation, ConfirmReservation, CancelReservation)
   - **Gateway** â†’ **Payment Sim**: gRPC calls (CreatePaymentIntent, GetPaymentIntent, ProcessPayment)
   - **Reservation** â†’ **Inventory**: gRPC calls (CheckAvailability, CommitReservation, ReleaseHold)
   - **Reservation** â†’ **Payment Sim**: gRPC calls (CreatePaymentIntent, ConfirmPayment)
4. **Event Flow**: Reservation publishes events via EventBridge â†’ SQS â†’ Reservation Worker processing
5. **Real-time Updates**: Gateway â†’ Frontend via WebSocket for queue status, reservation updates

### Traffic Tacos Proto-Contracts í†µí•©

**í˜„ì¬ êµ¬í˜„ ìƒíƒœ:**
- âœ… **Reservation API**: Traffic Tacos proto-contracts êµ¬ì¡° ì ìš© ì™„ë£Œ
  - `common/v1/common.proto`: ê³µí†µ íƒ€ì… ì •ì˜ (ErrorCode, Money, Seat)
  - `reservation/v1/inventory.proto`: InventoryService ì •ì˜
  - `reservation/v1/reservation.proto`: ReservationService ì •ì˜
- âœ… **Payment Sim API**: ì¤‘ì•™í™”ëœ `github.com/traffic-tacos/proto-contracts` ëª¨ë“ˆ ì‚¬ìš©
- âœ… **Reservation** â†’ **Inventory**: gRPC í†µì‹  (CheckAvailability, HoldSeats, CommitReservation, ReleaseHold)
- âœ… **Reservation API gRPC Server**: í¬íŠ¸ 8011ì—ì„œ ReservationService ì œê³µ

**í•„ìš”í•œ gRPC ì„œë¹„ìŠ¤ êµ¬í˜„:**
- âŒ **Gateway** â†’ **Reservation**: `reservation.proto` gRPC í´ë¼ì´ì–¸íŠ¸ í•„ìš”
- âŒ **Inventory API**: Traffic Tacos proto-contracts êµ¬ì¡°ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ í•„ìš”
- âœ… **Payment Sim API**: proto-contracts ëª¨ë“ˆ ì‚¬ìš© ì¤‘

**Proto ìƒì„± ëª…ë ¹ì–´:**
- **Reservation API**: `./generate_proto.sh` (Traffic Tacos êµ¬ì¡°)
- **Inventory API**: `make generate` (ê¸°ì¡´ êµ¬ì¡°, ë§ˆì´ê·¸ë ˆì´ì…˜ í•„ìš”)
- **Gateway API**: `make generate` (proto ì„¤ì • í•„ìš”)
- **Payment Sim API**: proto-contracts ëª¨ë“ˆ ì‚¬ìš© (ë¡œì»¬ ìƒì„± ë¶ˆí•„ìš”)

**Proto íŒŒì¼ ìœ„ì¹˜:**
- `reservation-api/src/main/proto/` (Traffic Tacos êµ¬ì¡°: common/v1, reservation/v1)
- `inventory-api/proto/` (Go ì„œë²„, ê¸°ì¡´ êµ¬ì¡°)
- `gateway-api/proto/` (Go í´ë¼ì´ì–¸íŠ¸, ìƒì„± í•„ìš”)
- `payment-sim-api/` proto-contracts ëª¨ë“ˆ ì‚¬ìš©

### Database Schema Patterns
- **DynamoDB Tables**: `reservations`, `orders`, `idempotency`, `outbox` (reservation-api)
- **Inventory Tables**: `inventory`, `inventory_seats` with optimistic locking
- **Composite Keys**: PK/SK patterns for efficient queries and relationships

## Performance Targets

- **Throughput**: 30k RPS system-wide
- **Latency**: P95 < 120ms (excluding payment confirmation)
- **Error Rate**: < 1%
- **Availability**: 99.9% target
- **Reservation Hold**: 60-second automatic expiry

## Independent Service Deployment

Each service is designed for **independent deployment** with its own:

- **Git Repository**: Separate repositories in production
- **Dockerfile**: Container build and deployment
- **CI/CD Pipeline**: Independent build, test, and deployment
- **Configuration**: Service-specific environment variables and config files

### Docker Build Per Service

Each service includes its own Dockerfile for containerized deployment:

```bash
# Reservation API
cd reservation-api && docker build -t reservation-api:latest .

# Inventory API
cd inventory-api && docker build -t inventory-api:latest .

# Payment Sim API
cd payment-sim-api && docker build -t payment-sim-api:latest .

# Gateway API
cd gateway-api && docker build -t gateway-api:latest .
```

## Local Development Setup

### All Services Environment (Recommended)

Use the **master local development script** to run all 4 services together:

**Quick Start:**
```bash
# Start all services with infrastructure
./run_local_all.sh start

# Test connections between services
./test_connections.sh test

# Stop all services
./run_local_all.sh stop
```

**AWS Environment Setup:**
For local development, services use LocalStack for AWS simulation. For production or AWS integration testing:

```bash
# Discover and configure actual AWS resources
./discover_aws_resources.sh generate

# Set AWS credentials (if not using IAM roles)
export AWS_REGION=ap-northeast-2
export AWS_PROFILE=your-profile

# Apply generated .env files to service configurations
# (Generated files will be in aws_config_YYYYMMDD_HHMMSS/ directory)
```

**Traffic Tacos MSA í¬íŠ¸ í• ë‹¹:**
- **Gateway API**: `http://localhost:8000` (REST), `grpc://localhost:8001` (gRPC Server)
- **Reservation API**: `http://localhost:8010` (REST), `grpc://localhost:8011` (gRPC Server)
- **Inventory API**: `http://localhost:8020` (REST), `grpc://localhost:8021` (gRPC Server)
- **Payment Sim API**: `http://localhost:8030` (REST), `grpc://localhost:8031` (gRPC Server)
- **Reservation Worker**: `http://localhost:8040` (REST), `grpc://localhost:8041` (gRPC Server)

**Infrastructure Ports:**
- **LocalStack**: `http://localhost:4566` (AWS services simulation)
- **OTEL Collector**: `4317` (gRPC), `4318` (HTTP)
- **Prometheus**: `http://localhost:4090` (metrics collection)
- **DynamoDB**: Uses AWS DynamoDB in ap-northeast-2 region (no local port)

### Individual Service Development

Each service can also be developed independently:

**Prerequisites**: Docker, Docker Compose, Java 17+, Go 1.24+

**Reservation API (Most Complete Environment):**
```bash
cd reservation-api && ./run_local.sh start
```

**Other Services:**
```bash
# Build and run individually
cd [service-name]
make build && ./[service-name]  # For Go services
./gradlew bootRun              # For reservation-api
```

### Connection Testing

The `test_connections.sh` script provides comprehensive connectivity testing:

```bash
# Test all service connections (HTTP + gRPC)
./test_connections.sh test

# Test specific service
./test_connections.sh test gateway

# Test gRPC connections specifically
./test_connections.sh grpc

# Show all service endpoints
./test_connections.sh endpoints
```

**gRPC Connection Testing:**
```bash
# Test inventory gRPC (currently working)
grpcurl -plaintext localhost:8021 list

# Test reservation gRPC (Traffic Tacos proto-contracts)
grpcurl -plaintext localhost:8011 list

# Test payment gRPC (working - pure gRPC service)
grpcurl -plaintext localhost:8031 list
```

### Development Workflow

1. **Start Environment**: `./run_local_all.sh start`
2. **Verify Connections**: `./test_connections.sh test`
3. **Run Integrated Tests**: `./test_all_integrated.sh quick`
4. **Development**: Edit code, services auto-restart or manual restart
5. **Health Monitoring**: `./health_check.sh monitor`
6. **Full Test Suite**: `./test_all_integrated.sh full`
7. **Stop Environment**: `./run_local_all.sh stop`

## Integrated Testing Suite

The platform includes comprehensive testing tools that orchestrate all components together:

### Master Test Orchestration (`test_all_integrated.sh`)

**Complete Test Suite:**
```bash
# Full integration test suite (all components)
./test_all_integrated.sh full

# Quick smoke tests (faster validation)
./test_all_integrated.sh quick

# Component-specific testing
./test_all_integrated.sh backend
./test_all_integrated.sh frontend
./test_all_integrated.sh worker
./test_all_integrated.sh integration
./test_all_integrated.sh performance
```

**Advanced Options:**
```bash
# Parallel testing for faster execution
./test_all_integrated.sh full --parallel

# Custom timeout settings
./test_all_integrated.sh backend --timeout 600

# Skip cleanup for debugging
./test_all_integrated.sh quick --no-cleanup
```

### Test Phases & Coverage

**Phase 1: Prerequisites**
- âœ… Tool availability (Docker, Node.js, Go, Java)
- âœ… Port availability check
- âœ… Environment validation

**Phase 2: Infrastructure**
- âœ… DynamoDB Local startup
- âœ… LocalStack (AWS services simulation)
- âœ… OTEL Collector, Prometheus setup
- âœ… Table creation and configuration

**Phase 3: Service Building**
- âœ… Backend services compilation (Go, Kotlin)
- âœ… Frontend build process (React/Vite)
- âœ… Parallel building support
- âœ… Build artifact validation

**Phase 4: Service Startup**
- âœ… Sequential service startup with dependencies
- âœ… Health check waiting and validation
- âœ… Port binding verification
- âœ… Process monitoring

**Phase 5: Connection Testing**
- âœ… HTTP endpoint validation
- âœ… gRPC service connectivity
- âœ… Database accessibility
- âœ… Inter-service communication paths

**Phase 6: Worker Testing**
- âœ… SQS queue setup and management
- âœ… Event generation and processing
- âœ… KEDA auto-scaling simulation
- âœ… Background job lifecycle

**Phase 7: Frontend Testing**
- âœ… React development server startup
- âœ… Unit tests (Jest + React Testing Library)
- âœ… Type checking (TypeScript)
- âœ… Linting and code quality
- âœ… Production build verification
- âœ… API connectivity testing

**Phase 8: Integration Testing**
- âœ… End-to-end reservation flow
- âœ… Cross-service data consistency
- âœ… Event-driven architecture validation
- âœ… Real-time features testing

**Phase 9: Performance Testing**
- âœ… Load testing for each service
- âœ… Resource usage monitoring
- âœ… Response time validation
- âœ… Concurrent request handling

### Component-Specific Testing

**Backend Services Testing:**
```bash
# Test individual backend components
./test_connections.sh test gateway
./test_connections.sh test reservation
./test_connections.sh grpc

# gRPC-specific testing
grpcurl -plaintext localhost:8021 list  # Inventory
grpcurl -plaintext localhost:8021 inventory.v1.Inventory/CheckAvailability
```

**Frontend Testing:**
```bash
# Complete frontend test suite
./test_frontend.sh full-test

# Development workflow
./test_frontend.sh setup
./test_frontend.sh dev

# Individual test types
./test_frontend.sh unit
./test_frontend.sh lint
./test_frontend.sh type-check
./test_frontend.sh build
./test_frontend.sh api-test
./test_frontend.sh e2e
```

**Worker Testing:**
```bash
# Worker functionality testing
./test_worker_local.sh setup
./test_worker_local.sh load 10
./test_worker_local.sh keda

# Monitor worker processing
./test_worker_local.sh monitor
```

### Health Monitoring (`health_check.sh`)

**Real-time Health Monitoring:**
```bash
# Single health check
./health_check.sh check

# Continuous monitoring
./health_check.sh monitor

# Quick status summary
./health_check.sh summary

# System resources only
./health_check.sh resources

# Process status only
./health_check.sh processes
```

**Health Check Features:**
- ğŸ” **Service Availability**: HTTP/gRPC endpoint validation
- ğŸ“Š **Performance Metrics**: Response times, resource usage
- ğŸš¨ **Alert System**: Consecutive failure detection
- ğŸ“ˆ **Resource Monitoring**: CPU, memory, disk usage
- ğŸ”„ **Process Monitoring**: Service PID tracking and health

### Test Results & Reporting

**Comprehensive Test Reports:**
- âœ… **Test Coverage**: Pass/fail status for all components
- â±ï¸ **Performance Metrics**: Execution times per test phase
- ğŸ“‹ **Detailed Logging**: Component-specific test results
- ğŸ¯ **Success Rate**: Overall platform health percentage
- ğŸš¨ **Failure Analysis**: Specific failure points and diagnostics

**Example Test Output:**
```
=== Test Report Summary ===
Total Tests: 45
Passed: 43
Failed: 2
Success Rate: 95%

Detailed Results:
  Infrastructure Startup           âœ“ PASS  (12s)
  Backend Service Build           âœ“ PASS  (45s)
  Frontend Build                  âœ“ PASS  (32s)
  Service Connectivity            âœ“ PASS  (8s)
  gRPC Communication              âœ“ PASS  (5s)
  Worker Processing               âœ— FAIL  (15s)
  E2E Integration                 âœ“ PASS  (20s)
  Performance Validation          âœ— FAIL  (30s)
```

### Debugging & Troubleshooting

**When Tests Fail:**
1. **Check Logs**: `tail -f logs/[service-name].log`
2. **Manual Service Check**: `./test_connections.sh test [service]`
3. **Health Status**: `./health_check.sh check`
4. **Resource Issues**: `./health_check.sh resources`
5. **Process Status**: `./health_check.sh processes`

**Common Issues & Solutions:**
- **Port Conflicts**: Use `--no-cleanup` to debug, check `lsof -i :8000-8040` or `lsof -i :3000,4090,4566`
- **Build Failures**: Check service-specific build logs
- **Connection Issues**: Verify service startup order and dependencies
- **Resource Constraints**: Monitor memory/CPU usage during tests
- **Timeout Issues**: Increase timeout with `--timeout` option

### Reservation Worker Local Testing

The **reservation-worker** is a Kubernetes Job with KEDA auto-scaling, which requires a different local testing approach:

**Testing Strategies:**

1. **Standalone Mode** (Recommended for Development):
   ```bash
   # Run worker as a regular Go/Kotlin application
   cd reservation-worker
   go run cmd/worker/main.go --mode=standalone
   # OR for Kotlin
   ./gradlew bootRun --args="--mode=standalone"
   ```

2. **SQS Simulation Mode**:
   ```bash
   # Use LocalStack SQS with polling simulation
   cd reservation-worker
   export SQS_QUEUE_URL=http://localhost:4566/000000000000/reservation-events
   go run cmd/worker/main.go --mode=sqs-local
   ```

3. **Docker Job Simulation**:
   ```bash
   # Simulate K8s job behavior locally
   docker run --rm --network host \
     -e SQS_QUEUE_URL=http://localhost:4566/000000000000/reservation-events \
     -e AWS_REGION=ap-northeast-2 \
     reservation-worker:latest
   ```

4. **Local Kubernetes with KEDA** (Advanced):
   ```bash
   # Requires: kind/minikube + KEDA installation
   kind create cluster --name traffic-tacos
   kubectl apply -f https://github.com/kedacore/keda/releases/download/v2.12.0/keda-2.12.0.yaml
   kubectl apply -f k8s/reservation-worker-job.yaml
   ```

**Event Testing:**
```bash
# Trigger worker events via reservation API
curl -X POST http://localhost:8010/v1/reservations \
  -H "Content-Type: application/json" \
  -H "Idempotency-Key: $(uuidgen)" \
  -d '{"event_id": "test", "qty": 1}'

# Monitor worker processing
tail -f logs/reservation-worker.log
```

**Queue Monitoring:**
```bash
# Check SQS queue depth (triggers KEDA scaling)
aws sqs get-queue-attributes \
  --queue-url http://localhost:4566/000000000000/reservation-events \
  --attribute-names ApproximateNumberOfMessages \
  --endpoint-url http://localhost:4566
```

**Key Differences from Web Services:**
- **Event-driven**: Triggered by SQS messages, not HTTP requests
- **Batch processing**: Processes multiple reservations per job run
- **Auto-scaling**: KEDA scales based on queue depth (0-N pods)
- **Stateless**: Each job run is independent
- **No persistent server**: Starts, processes, and terminates

### Frontend (Reservation Web) Local Development

The **reservation-web** is a React frontend that requires a different development approach from backend services:

**Development Setup:**
```bash
cd reservation-web

# Install dependencies
npm install
# OR
yarn install

# Start development server
npm run dev
# OR
yarn dev

# Build for production
npm run build
# OR
yarn build
```

**Frontend-Specific Development:**
1. **Development Server**: Runs on port 3000 with hot reload
2. **API Integration**: Connects to Gateway API on port 8080
3. **Real-time Features**: WebSocket connection for live updates
4. **State Management**: React state + Context API or Redux Toolkit
5. **Routing**: React Router for SPA navigation

**Testing Approaches:**

1. **Standalone Development** (Frontend Only):
   ```bash
   cd reservation-web
   npm run dev
   # Access: http://localhost:3000
   # Uses mock data or external API
   ```

2. **Full Stack Development** (Recommended):
   ```bash
   # Terminal 1: Start backend services
   ./run_local_all.sh start

   # Terminal 2: Start frontend
   cd reservation-web && npm run dev
   ```

3. **Docker Development**:
   ```bash
   # Build frontend Docker image
   cd reservation-web && docker build -t reservation-web:latest .

   # Run with backend services
   docker run -p 3000:3000 --network host reservation-web:latest
   ```

**Frontend Testing:**
```bash
cd reservation-web

# Unit tests (Jest + React Testing Library)
npm run test

# E2E tests (Cypress or Playwright)
npm run test:e2e

# Visual testing (Storybook)
npm run storybook

# Lint and type check
npm run lint
npm run type-check
```

**API Integration Configuration:**
```javascript
// Environment variables for API endpoints
VITE_API_BASE_URL=http://localhost:8000      // Gateway API (Entry point)
VITE_WS_URL=ws://localhost:8000/ws          // WebSocket for real-time updates
VITE_RESERVATION_API=http://localhost:8010  // Direct reservation API (optional)
VITE_APP_ENV=development
```

**Key Differences from Backend Services:**
- **Client-side rendering**: Runs in browser, not server
- **Hot reload**: Instant updates during development
- **Build process**: Transpilation and bundling required
- **Static serving**: Final build serves static files
- **Browser debugging**: DevTools instead of server logs
- **CORS considerations**: Cross-origin requests to backend


## Reservation-web ì´ ì‹¤ì œë¡œ í˜¸ì¶œí•˜ëŠ” API

#### ëŒ€ê¸°ì—´ ê´€ë¦¬
- `POST /api/v1/queue/join` - ëŒ€ê¸°ì—´ ì°¸ì—¬
- `GET /api/v1/queue/status` - ìƒíƒœ ì¡°íšŒ
- `POST /api/v1/queue/enter` - ì…ì¥ ìš”ì²­
- `DELETE /api/v1/queue/leave` - ëŒ€ê¸°ì—´ ì´íƒˆ

#### ì˜ˆì•½ ê´€ë¦¬
- `GET /api/v1/events/{id}/availability` - ê°€ìš©ì„± ì¡°íšŒ
- `POST /api/v1/reservations` - ì˜ˆì•½ ìƒì„±
- `GET /api/v1/reservations/{id}` - ì˜ˆì•½ ì¡°íšŒ
- `POST /api/v1/reservations/{id}/confirm` - ì˜ˆì•½ í™•ì •
- `DELETE /api/v1/reservations/{id}` - ì˜ˆì•½ ì·¨ì†Œ

#### ê²°ì œ ì²˜ë¦¬
- `POST /api/v1/payments/intent` - ê²°ì œ ì¸í…íŠ¸ ìƒì„±
- `POST /api/v1/payments/process` - ê²°ì œ ì²˜ë¦¬
- `GET /api/v1/payments/{id}/status` - ê²°ì œ ìƒíƒœ ì¡°íšŒ

## ê° API ìƒì„¸

ëŒ€ê¸°ì—´ ê´€ë¦¬

POST /api/v1/queue/join
- ê²½ë¡œ: Browser â†’ (REST) gateway-api â†’ (ë‚´ë¶€ í ëª¨ë“ˆ/ìºì‹œ; í•„ìš” ì‹œ Redis ì‚¬ìš©)
- ìƒì„¸: JWT(ì„ íƒ) í™•ì¸ â†’ ëŒ€ê¸°ì—´ í† í° ìƒì„± â†’ ìºì‹œì— ë“±ë¡ â†’ í† í° ë°˜í™˜
- ì‘ë‹µ: {"waiting_token": "...", "position_hint": ...}

GET /api/v1/queue/status?token=...
- ê²½ë¡œ: Browser â†’ (REST) gateway-api â†’ (ë‚´ë¶€ í ìƒíƒœ ì¡°íšŒ; Redis)
- ìƒì„¸: í† í° ìœ íš¨ì„±/ETA ê³„ì‚°(ìºì‹œ) â†’ ìƒíƒœ ë°˜í™˜
- ì‘ë‹µ: {"status":"waiting|ready|expired","eta_sec":...}

POST /api/v1/queue/enter
- ê²½ë¡œ: Browser â†’ (REST) gateway-api â†’ (ë‚´ë¶€ ê²€ì¦/ë°œê¸‰)
- ìƒì„¸: waiting_token ê²€ì¦ â†’ reservation_token ë°œê¸‰(ìºì‹œ)
- ì‘ë‹µ: {"admission":"granted","reservation_token":"...","ttl_sec":...}

DELETE /api/v1/queue/leave
- ê²½ë¡œ: Browser â†’ (REST) gateway-api â†’ (ë‚´ë¶€ í ìƒíƒœ ë³€ê²½; Redis)
- ìƒì„¸: í† í° ë¬´íš¨í™”/ì •ë¦¬ â†’ OK ë°˜í™˜

â¸»

ì˜ˆì•½ ê´€ë¦¬

GET /api/v1/events/{id}/availability
- ê²½ë¡œ: Browser â†’ (REST) gateway-api â†’ (gRPC) inventory-svc.Inventory/CheckAvailability
- ìƒì„¸: gatewayê°€ {event_id, qty? seat_ids?}ë¡œ gRPC í˜¸ì¶œ â†’ ê°€ìš©/ë¶ˆê°€ ì¢Œì„ ëª©ë¡ ìˆ˜ì‹  â†’ RESTë¡œ ë³€í™˜í•´ ì‘ë‹µ

POST /api/v1/reservations
- í—¤ë”: Idempotency-Key: <uuid> (í•„ìˆ˜), Authorization: Bearer <JWT>
- ê²½ë¡œ: Browser â†’ (REST) gateway-api:8000 â†’ (REST) reservation-api:8010 /v1/reservations â†’ (gRPC) inventory-svc:8021.Commit/Check
- ìƒì„¸: gatewayëŠ” ì¸ì¦/ë ˆì´íŠ¸ë¦¬ë°‹/ë©±ë“±í‚¤ ê²€ì¦ë§Œ í•˜ê³  reservation-apië¡œ ì „ë‹¬.
reservation-apiëŠ” ë©±ë“± ì²˜ë¦¬ + 60s ë§Œë£Œ ìŠ¤ì¼€ì¤„(EventBridge Scheduler) ë“±ë¡ + í•„ìš” ì‹œ inventory ê°€ìš©ì„± í™•ì¸ í›„ HOLD ê¸°ë¡.

GET /api/v1/reservations/{id}
- ê²½ë¡œ: Browser â†’ (REST) gateway-api:8000 â†’ (REST) reservation-api:8010 /v1/reservations/{id}
- ìƒì„¸: ìƒíƒœ/HOLD ë§Œë£Œ ì‹œê° ë“± ì¡°íšŒë¥¼ reservation-apiì—ì„œ ê°€ì ¸ì™€ ê·¸ëŒ€ë¡œ ë°˜í™˜.

POST /api/v1/reservations/{id}/confirm
- í—¤ë”: Idempotency-Key: <uuid> (ê¶Œì¥)
- ê²½ë¡œ: Browser â†’ (REST) gateway-api:8000 â†’ (REST) reservation-api:8010 /v1/reservations/confirm â†’ (gRPC) inventory-svc:8021.CommitReservation
- ìƒì„¸: reservation-apiê°€ ê²°ì œ ìŠ¹ì¸ ì—¬ë¶€ í™•ì¸(ì›¹í›…/ì´ë²¤íŠ¸ ê¸°ì¤€) í›„ inventory CommitReservation í˜¸ì¶œ â†’ í™•ì •/ì£¼ë¬¸ ìƒì„± â†’ ê²°ê³¼ ë°˜í™˜.

DELETE /api/v1/reservations/{id}
- ê²½ë¡œ: Browser â†’ (REST) gateway-api:8000 â†’ (REST) reservation-api:8010 /v1/reservations/cancel â†’ (gRPC) inventory-svc:8021.ReleaseHold
- ìƒì„¸: reservation-apiê°€ ReleaseHold í˜¸ì¶œë¡œ ì¬ê³  ë³µêµ¬ â†’ ìƒíƒœ CANCELLEDë¡œ ê°±ì‹  í›„ ì‘ë‹µ.

â¸»

ê²°ì œ ì²˜ë¦¬

POST /api/v1/payments/intent
- ê²½ë¡œ: Browser â†’ (REST) gateway-api:8000 â†’ (gRPC) payment-sim-api:8031 payment.v1.PaymentService/CreatePaymentIntent
- ìƒì„¸: ê²°ì œ ì‹œë‚˜ë¦¬ì˜¤(PAYMENT_SCENARIO_APPROVE|FAIL|DELAY|RANDOM)ì™€ webhook_url(reservation-api:8010 ë‚´ë¶€ ì›¹í›…)ì„ ì „ë‹¬.
payment-sim-apiëŠ” ì§€ì—° í›„ ì›¹í›…(REST POST) + EventBridge ì´ë²¤íŠ¸ ë°œí–‰ â†’ reservation-api:8010 ì²˜ë¦¬.

POST /api/v1/payments/process
- ê²½ë¡œ: Browser â†’ (REST) gateway-api:8000 â†’ (gRPC) payment-sim-api:8031 payment.v1.PaymentService/ProcessPayment
- ìƒì„¸: ìˆ˜ë™ íŠ¸ë¦¬ê±°/ì¦‰ì‹œ ì²˜ë¦¬ìš©(í…ŒìŠ¤íŠ¸ìš©) ìš”ì²­ì„ payment-sim-apië¡œ ì „ë‹¬ â†’ payment-sim-apiê°€ ì›¹í›… + EventBridgeë¥¼ reservation-api:8010ì— ë°œì†¡.

GET /api/v1/payments/{id}/status
- ê²½ë¡œ: Browser â†’ (REST) gateway-api:8000 â†’ (gRPC) payment-sim-api:8031 payment.v1.PaymentService/GetPaymentStatus
- ìƒì„¸: payment-sim-apiê°€ ë³´ìœ í•œ intent ìƒíƒœ(PAYMENT_STATUS_PENDING|COMPLETED|FAILED)ë¥¼ ì¡°íšŒí•´ ë°˜í™˜.

â¸»

ë³´ì¡° íë¦„(ë°±ê·¸ë¼ìš´ë“œ/ì´ë²¤íŠ¸)
- ì˜ˆì•½ ë§Œë£Œ(60s): reservation-apiê°€ ìƒì„± ì‹œ EventBridge Schedulerì— ë§Œë£Œ ì´ë²¤íŠ¸ ë“±ë¡ â†’ ë§Œë£Œ ì‹œ reservation-api ë‚´ë¶€ í•¸ë“¤ëŸ¬(ë˜ëŠ” SQS â†’ reservation-worker)ê°€ inventory-svc.ReleaseHoldì™€ ìƒíƒœ EXPIRED ê°±ì‹  ìˆ˜í–‰.
- ê²°ì œ ì›¹í›…: payment-sim-api â†’ (REST) reservation-api /internal/payment/webhook â†’ reservation-apiê°€ ìƒíƒœ ê°±ì‹ /í™•ì • íŠ¸ë¦¬ê±° â†’ í•„ìš” ì‹œ (gRPC) inventory-svc.CommitReservation.
- Worker ì†Œë¹„: reservation-workerëŠ” SQSì—ì„œ reservation.expired|payment.approved|payment.failed ì´ë²¤íŠ¸ë¥¼ ì½ì–´ inventory-svc gRPCì™€ reservation-api RESTë¥¼ í˜¸ì¶œ(autoscaleì€ KEDA).

## reservation-workerê°€ í•„ìš”í•œ ìˆœê°„

1. ì˜ˆì•½ ë§Œë£Œ ì²˜ë¦¬ (60ì´ˆ Hold Expiry)
- ìœ ì €ê°€ ì¢Œì„ì„ ì„ íƒí•˜ë©´ â†’ reservation-apiê°€ DynamoDBì— HOLD ìƒíƒœë¡œ ì €ì¥ + EventBridge Scheduler(60s í›„) ë“±ë¡
- 60ì´ˆ ë’¤ EventBridge â†’ SQS ì´ë²¤íŠ¸ ë°œí–‰
- reservation-workerê°€ ì´ SQS ì´ë²¤íŠ¸ë¥¼ ì†Œë¹„í•´ì„œ:
- inventory-svc:8021ì— gRPC ReleaseHold â†’ ì¢Œì„/ì¬ê³  ë³µêµ¬
- reservation-api:8010 REST /internal/reservations/{id} PATCH â†’ ìƒíƒœ EXPIREDë¡œ ë³€ê²½

ğŸ‘‰ ì—†ìœ¼ë©´, ë§Œë£Œëœ ì˜ˆì•½ì´ DBì— ê³„ì† HOLDë¡œ ë‚¨ì•„ì„œ ì˜¤ë²„ì…€ ë°œìƒ ìœ„í—˜.

â¸»

2. ê²°ì œ ê²°ê³¼ í›„ì† ì²˜ë¦¬
- payment-sim-apiê°€ webhookìœ¼ë¡œ reservation-apiì— â€œìŠ¹ì¸/ì‹¤íŒ¨â€ ì´ë²¤íŠ¸ ì „ë‹¬
- reservation-apiëŠ” ì´ë²¤íŠ¸ë¥¼ SQSì— Outbox í˜•íƒœë¡œ ë°œí–‰ (event type: payment.approved / payment.failed)
- reservation-workerê°€ ì´ ì´ë²¤íŠ¸ë¥¼ ì†Œë¹„í•´ì„œ:
- payment.approved â†’ inventory-svc:8021 CommitReservation â†’ ì¢Œì„ ìƒíƒœ SOLD í™•ì •
- payment.failed â†’ inventory-svc:8021 ReleaseHold + reservation-api:8010 ìƒíƒœ CANCELLED

ğŸ‘‰ ì—†ìœ¼ë©´, ê²°ì œëŠ” ì„±ê³µí–ˆëŠ”ë° ì¢Œì„ í™•ì •ì´ ì•ˆ ë˜ê±°ë‚˜, ê²°ì œê°€ ì‹¤íŒ¨í–ˆëŠ”ë° ì¢Œì„ì´ í’€ë¦¬ì§€ ì•ŠëŠ” ë¬¸ì œ ë°œìƒ.

â¸»

3. ì¥ì• /ë³´ìƒ ì²˜ë¦¬
- ì˜ˆì•½ ì¤‘ê°„ì— Downstream ì—ëŸ¬ê°€ ë‚˜ë©´ reservation-apiëŠ” SQSë¡œ ë³´ìƒ ì´ë²¤íŠ¸ë¥¼ ë°œí–‰í•  ìˆ˜ ìˆìŒ
- workerê°€ ì´ë¥¼ ë°›ì•„ ì¬ì‹œë„/ë³´ìƒ íŠ¸ëœì­ì…˜ ìˆ˜í–‰ (e.g., ì¢Œì„ ê°•ì œ ë³µêµ¬, ì˜ˆì•½ ê°•ì œ ì·¨ì†Œ)