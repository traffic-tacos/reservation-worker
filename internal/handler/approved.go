package handler

import (
	"context"
	"fmt"
	"time"

	"github.com/traffic-tacos/proto-contracts/gen/go/reservation/v1"
	"github.com/traffic-tacos/reservation-worker/internal/client"
	"github.com/traffic-tacos/reservation-worker/internal/observability"
	"go.opentelemetry.io/otel/attribute"
	"go.uber.org/zap"
)

// ApprovedHandler handles payment.approved events
type ApprovedHandler struct {
	inventoryClient   *client.InventoryClient
	reservationClient *client.ReservationClient
	logger            *observability.Logger
	metrics           *observability.Metrics
}

// NewApprovedHandler creates a new approved event handler
func NewApprovedHandler(
	inventoryClient *client.InventoryClient,
	reservationClient *client.ReservationClient,
	logger *observability.Logger,
	metrics *observability.Metrics,
) *ApprovedHandler {
	return &ApprovedHandler{
		inventoryClient:   inventoryClient,
		reservationClient: reservationClient,
		logger:            logger,
		metrics:           metrics,
	}
}

// Handle processes a payment approved event
func (h *ApprovedHandler) Handle(ctx context.Context, event *Event) error {
	start := time.Now()

	// Parse event detail
	detail, err := event.ParseEventDetail()
	if err != nil {
		h.metrics.RecordProcessingDuration("approved", observability.OutcomeInvalidPayload, time.Since(start).Seconds())
		return fmt.Errorf("failed to parse event detail: %w", err)
	}

	approvedDetail, ok := detail.(*PaymentApprovedDetail)
	if !ok {
		h.metrics.RecordProcessingDuration("approved", observability.OutcomeInvalidPayload, time.Since(start).Seconds())
		return fmt.Errorf("invalid event detail type for approved event")
	}

	// Start tracing span
	ctx, span := observability.StartSpan(ctx, "handle_payment_approved")
	span.SetAttributes(
		attribute.String("reservation_id", approvedDetail.ReservationID),
		attribute.String("payment_intent_id", approvedDetail.PaymentIntentID),
		attribute.Int64("amount", approvedDetail.Amount),
	)
	defer span.End()

	logger := h.logger.WithEvent(event.Type, approvedDetail.ReservationID, approvedDetail.EventID)
	if event.TraceID != "" {
		logger = h.logger.WithTrace(event.TraceID)
	}

	logger.Info("Processing payment approved event",
		zap.String("reservation_id", approvedDetail.ReservationID),
		zap.String("payment_intent_id", approvedDetail.PaymentIntentID),
		zap.Int64("amount", approvedDetail.Amount),
	)

	// Step 1: Update reservation status to CONFIRMED
	statusReq := &client.UpdateStatusRequest{
		ReservationID: approvedDetail.ReservationID,
		Status:        client.StatusConfirmed,
		// OrderID will be generated by reservation service
	}

	if err := h.reservationClient.UpdateReservationStatus(ctx, statusReq); err != nil {
		observability.SetSpanError(span, err)
		h.metrics.RecordProcessingDuration("approved", observability.OutcomeDownstreamError, time.Since(start).Seconds())
		logger.Error("Failed to update reservation status",
			zap.Error(err),
			zap.String("reservation_id", approvedDetail.ReservationID),
		)
		return fmt.Errorf("failed to update reservation status: %w", err)
	}

	logger.Info("Successfully updated reservation status to CONFIRMED",
		zap.String("reservation_id", approvedDetail.ReservationID),
	)

	// Step 2: Commit reservation in inventory service (optional - mark seats as SOLD)
	if approvedDetail.EventID != "" && len(approvedDetail.SeatIDs) > 0 {
		commitReq := &reservationv1.CommitReservationRequest{
			EventId:         approvedDetail.EventID,
			ReservationId:   approvedDetail.ReservationID,
			Quantity:        int32(approvedDetail.Quantity),
			SeatIds:         approvedDetail.SeatIDs,
			PaymentIntentId: approvedDetail.PaymentIntentID,
		}

		if err := h.inventoryClient.CommitReservation(ctx, commitReq); err != nil {
			// Log error but don't fail the entire operation
			// The reservation is already confirmed, inventory is in a recoverable state
			logger.Error("Failed to commit reservation in inventory service",
				zap.Error(err),
				zap.String("reservation_id", approvedDetail.ReservationID),
				zap.String("payment_intent_id", approvedDetail.PaymentIntentID),
			)
			// Don't return error here - reservation is already confirmed
		} else {
			logger.Info("Successfully committed reservation in inventory service",
				zap.String("reservation_id", approvedDetail.ReservationID),
			)
		}
	}

	// Success
	observability.SetSpanSuccess(span)
	duration := time.Since(start)
	h.metrics.RecordProcessingDuration("approved", observability.OutcomeSuccess, duration.Seconds())

	logger.Info("Successfully processed payment approved event",
		zap.String("reservation_id", approvedDetail.ReservationID),
		zap.String("payment_intent_id", approvedDetail.PaymentIntentID),
		zap.Duration("duration", duration),
	)

	return nil
}